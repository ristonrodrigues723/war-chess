<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Chessboard with AI</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #2c3e50;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    #chessboard {
    
      width: 600px;
      height: 600px;
      perspective: 1000px;
    }
    
    .square {
    
      width: 75px;
      height: 75px;
      border: 1px solid #333;
      box-shadow: inset 0px 0px 5px rgba(0, 0, 0, 0.2);
    }
    
    .piece {
    
      position: absolute;
      transform-style: preserve-3d;
      box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.3);
    }
    controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
    }
    
    button {
    
      background-color: #141414;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }
    #message-box {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.8);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 18px;
    }
      </style>
</head>
<body>
  <div id="controls">
    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
  </div>
  <div id="message-box"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script> 
  <script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x2c3e50);
document.body.appendChild(renderer.domElement);

const boardWidth = 8;
const boardHeight = 8;
const squareSize = 1;
const boardGroup = new THREE.Group();

const pawnGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.6, 32);
const knightGeometry = new THREE.ConeGeometry(0.3, 0.7, 32);
const bishopGeometry = new THREE.ConeGeometry(0.3, 0.8, 32);
const queenGeometry = new THREE.SphereGeometry(0.4, 32, 32);
const kingGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.9, 32);

const whiteMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
const blackMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });

let tankModel;

function loadTankModel() {
  const loader = new THREE.GLTFLoader();
  return new Promise((resolve, reject) => {
    loader.load(
      'gift/scene.gltf',
      (gltf) => {
        tankModel = gltf.scene;
        tankModel.scale.set(0.1, 0.1, 0.1); // Adjust scale as needed
        resolve();
      },
      undefined,
      reject
    );
  });
}

function createSquare(i, j) {
  const geometry = new THREE.BoxGeometry(squareSize, 0.1, squareSize);
  const material = new THREE.MeshPhongMaterial({
    color: (i + j) % 2 === 0 ? 0xecf0f1 : 0x34495e,
    shininess: 30,
  });
  const square = new THREE.Mesh(geometry, material);
  square.position.set(i * squareSize, 0, j * squareSize);
  return square;
}

function createPiece(geometry, material, x, z, type, color) {
  let piece;
  if (type === 'rook') {
    piece = tankModel.clone();
    piece.position.y = 0.05;
  } else {
    piece = new THREE.Mesh(geometry, material);
    piece.position.y = 0.3;
  }
  piece.position.set(x * squareSize, piece.position.y, z * squareSize);
  if (type === 'rook' && color === 'black') {
    piece.rotation.y = Math.PI;
  }
  piece.userData = { type, color, x, z };
  return piece;
}

const pieces = [];
async function setupChessPieces() {
  await loadTankModel();

  const setupOrder = [
    { geo: null, type: 'rook' },
    { geo: knightGeometry, type: 'knight' },
    { geo: bishopGeometry, type: 'bishop' },
    { geo: queenGeometry, type: 'queen' },
    { geo: kingGeometry, type: 'king' },
    { geo: bishopGeometry, type: 'bishop' },
    { geo: knightGeometry, type: 'knight' },
    { geo: null, type: 'rook' }
  ];

  for (let i = 0; i < 8; i++) {
    pieces.push(createPiece(pawnGeometry, whiteMaterial, i, 1, 'pawn', 'white'));
    pieces.push(createPiece(pawnGeometry, blackMaterial, i, 6, 'pawn', 'black'));
    pieces.push(createPiece(setupOrder[i].geo, whiteMaterial, i, 0, setupOrder[i].type, 'white'));
    pieces.push(createPiece(setupOrder[i].geo, blackMaterial, i, 7, setupOrder[i].type, 'black'));
  }

  pieces.forEach(piece => boardGroup.add(piece));
}

// ... (rest of the code for game logic, including isValidMove, movePiece, etc.)

async function initializeGame() {
  for (let i = 0; i < boardWidth; i++) {
    for (let j = 0; j < boardHeight; j++) {
      boardGroup.add(createSquare(i, j));
    }
  }

  await setupChessPieces();
  scene.add(boardGroup);

  boardGroup.position.set(-3.5 * squareSize, 0, -3.5 * squareSize);

  const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
  scene.add(ambientLight);

  const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight1.position.set(5, 5, 5);
  scene.add(directionalLight1);

  const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
  directionalLight2.position.set(-5, 5, -5);
  scene.add(directionalLight2);

  camera.position.set(0, 7, 10);
  camera.lookAt(0, 0, 0);

  updateMessageBox("White's turn");
  animate();
}



initializeGame();


    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    renderer.domElement.addEventListener('mousedown', onMouseDown, false);
    renderer.domElement.addEventListener('wheel', onMouseWheel, false);

    document.getElementById('zoomInBtn').addEventListener('click', () => zoom(-1));
    document.getElementById('zoomOutBtn').addEventListener('click', () => zoom(1));

    updateMessageBox("White's turn");
 
    initializeGame();
  </script>
</body>
</html>